---
title: "Film-Level Popularity Metrics (Depth & Breadth) — Netflix Top 10 (Films)"
author: "QIUJUN ZHANG"
date: "2026-02-15"
output: html_document
---

## Overview

This notebook builds **film-level popularity metrics** using only the cleaned Netflix Top 10 (Films) dataset you already produced.

### Inputs (from cleaned dataset)
We will use:
- `show_title` (film title)
- `country_name`
- `weekly_rank`
- `cumulative_weeks_in_top_10` (your `cuWk_top_10`)
- `week` (your numeric `week_number` index: 1, 2, 3, ...)

### Outputs (saved to `data/processed/`)
- `movie_country_table.csv` (movie × country collapsed table)
- `movie_popularity_metrics.csv` (**final movie-level table**)
- `anomaly_local_cult.csv` (10+ weeks but only 1–2 countries)
- `anomaly_global_flash.csv` (30+ countries but only 1 week)
- `persistence_vs_spread.png` (scatterplot)

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

```{r}
# Packages
library(dplyr)
library(stringr)
library(readr)
library(ggplot2)
library(knitr)
```

## 0) Load the cleaned dataset

This script assumes you already created the cleaned file from your cleaning Rmd.

```{r}
in_path <- "data/processed/netflix_films_clean.csv"
if (!file.exists(in_path)) in_path <- "/mnt/data/netflix_films_clean.csv"  # fallback for this environment

out_dir <- "data/processed"
if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

top10 <- read_csv(in_path, show_col_types = FALSE)

cat("Loaded:", in_path, "\n")
cat("Rows x Cols:", nrow(top10), "x", ncol(top10), "\n\n")

# Quick peek at columns (helps debugging if names differ)
print(names(top10))
```

---

## 1) Keep Films only + select needed columns

Even if your cleaned file is already Films-only, this filter is a safe guardrail.

We also create:
- `movie_key`: normalized key for grouping (lowercase + trimmed)
- `week_number`: your numeric week index (already numeric in your latest cleaned file)

```{r}
films <- top10 %>%
  filter(category == "Films" | is.na(category)) %>%  # robust if category is missing
  transmute(
    movie_title  = str_squish(show_title),                 # readable title
    movie_key    = str_to_lower(str_squish(show_title)),   # stable grouping key

    country_name = str_squish(country_name),

    week_number  = as.integer(week),
    weekly_rank  = as.integer(weekly_rank),

    cuWk_top_10  = as.integer(cumulative_weeks_in_top_10)
  )

cat("films rows/cols:", nrow(films), "x", ncol(films), "\n")
cat("unique movies:", n_distinct(films$movie_key), "\n")
cat("unique countries:", n_distinct(films$country_name), "\n\n")

kable(head(films, 10))
```

---

## 2) Collapse week-level rows → movie × country table

Why we do this: the raw data has **one row per week**.  
If we jump straight to “number of countries” or “best rank”, we can accidentally double-count.  
This collapse produces **one row per (movie, country)** with:

- `persistence_in_country`: max cumulative weeks observed in that country  
- `best_rank_in_country`: best rank the film achieved in that country  
- `first_week_in_country`, `last_week_in_country`: appearance window in that country  

```{r}
movie_country <- films %>%
  group_by(movie_key, movie_title, country_name) %>%
  summarise(
    persistence_in_country = max(cuWk_top_10, na.rm = TRUE),
    best_rank_in_country   = min(weekly_rank, na.rm = TRUE),
    first_week_in_country  = min(week_number, na.rm = TRUE),
    last_week_in_country   = max(week_number, na.rm = TRUE),
    .groups = "drop"
  )

cat("movie_country rows/cols:", nrow(movie_country), "x", ncol(movie_country), "\n\n")
kable(head(movie_country, 10))

write_csv(movie_country, file.path(out_dir, "movie_country_table.csv"))
cat("\nSaved: data/processed/movie_country_table.csv\n")
```

---

## 3) Collapse → movie-level popularity metrics (Depth & Breadth)

Now we compute **one row per movie**:

- **global_persistence (depth)**: max persistence in any one country  
- **global_spread (breadth)**: number of distinct countries  
- **global_duration (time span)**: last appearance week − first appearance week + 1  
- **best_rank**: best (minimum) rank achieved anywhere (1 is best)

```{r}
movie_summary <- movie_country %>%
  group_by(movie_key) %>%
  summarise(
    movie_title = first(movie_title),
    global_persistence = max(persistence_in_country, na.rm = TRUE),
    global_spread      = n_distinct(country_name),
    global_duration    = max(last_week_in_country, na.rm = TRUE) -
                         min(first_week_in_country, na.rm = TRUE) + 1,
    best_rank          = min(best_rank_in_country, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(global_spread), desc(global_persistence), best_rank)

cat("movie_summary rows/cols:", nrow(movie_summary), "x", ncol(movie_summary), "\n\n")
kable(head(movie_summary, 15))

write_csv(movie_summary, file.path(out_dir, "movie_popularity_metrics.csv"))
cat("\nSaved: data/processed/movie_popularity_metrics.csv  (FINAL movie-level table)\n")
```

---

## 4) Are globally distributed films more persistent?

We check correlation between:
- spread vs persistence  
- spread vs duration (optional but useful)

```{r}
spread_persist_cor  <- cor(movie_summary$global_spread, movie_summary$global_persistence, use = "complete.obs")
spread_duration_cor <- cor(movie_summary$global_spread, movie_summary$global_duration,    use = "complete.obs")

cat("Correlation(global_spread, global_persistence):", round(spread_persist_cor, 4), "\n")
cat("Correlation(global_spread, global_duration):   ", round(spread_duration_cor, 4), "\n")
```

---

## 5) Identify anomalies (two types)

### A) “Local cult”  
Stayed **10+ weeks** but only appeared in **1–2 countries**.

### B) “Global flash”  
Appeared in **30+ countries** but only lasted **1 week** anywhere.

```{r}
anomaly_local_cult <- movie_summary %>%
  filter(global_persistence >= 10, global_spread <= 2) %>%
  arrange(desc(global_persistence), best_rank)

anomaly_global_flash <- movie_summary %>%
  filter(global_spread >= 30, global_persistence == 1) %>%
  arrange(desc(global_spread), best_rank)

cat("Anomaly A (local cult) count:", nrow(anomaly_local_cult), "\n")
cat("Anomaly B (global flash) count:", nrow(anomaly_global_flash), "\n\n")

cat("Local cult preview:\n")
kable(head(anomaly_local_cult, 10))

cat("\nGlobal flash preview:\n")
kable(head(anomaly_global_flash, 10))

write_csv(anomaly_local_cult, file.path(out_dir, "anomaly_local_cult.csv"))
write_csv(anomaly_global_flash, file.path(out_dir, "anomaly_global_flash.csv"))

cat("\nSaved:\n- data/processed/anomaly_local_cult.csv\n- data/processed/anomaly_global_flash.csv\n")
```

---

## 6) Distributions + “% one-week hits”

```{r}
cat("Summary: global_persistence\n"); print(summary(movie_summary$global_persistence))
cat("\nSummary: global_spread\n");      print(summary(movie_summary$global_spread))
cat("\nSummary: global_duration\n");    print(summary(movie_summary$global_duration))

one_week_rate <- mean(movie_summary$global_persistence == 1, na.rm = TRUE)
cat("\n% one-week hits (global_persistence == 1):", round(one_week_rate, 4), "\n")
```

---

## 7) Scatterplot: persistence vs spread

```{r}
p <- ggplot(movie_summary, aes(x = global_spread, y = global_persistence)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE) +
  labs(
    x = "Global Spread (# countries)",
    y = "Global Persistence (max weeks in any country)",
    title = "Persistence vs Spread (Films)"
  )

p
```

```{r}
ggsave(
  filename = file.path(out_dir, "persistence_vs_spread.png"),
  plot = p,
  width = 7, height = 5, dpi = 200
)
cat("Saved plot: data/processed/persistence_vs_spread.png\n")
```

---

## 8) Correlation: best_rank vs persistence

Reminder: **best_rank smaller = better**.  
So a **negative** correlation means: films that peak higher tend to persist longer.

```{r}
rank_persist_cor <- cor(movie_summary$best_rank, movie_summary$global_persistence, use = "complete.obs")
cat("Correlation(best_rank, global_persistence):", round(rank_persist_cor, 4), "\n")
```

---

## 9) Final output recap

Your **final movie-level dataset** is:

- `data/processed/movie_popularity_metrics.csv`

with columns:

- `movie_title`
- `global_persistence`
- `global_spread`
- `global_duration`
- `best_rank`

```{r}
cat("Final table preview (top 10):\n")
kable(head(movie_summary, 10))
```
